export class UiLayer{
    constructor(pseudolayer, layerNumber) {
        // same id as the pseudolayer, can be used to get the DOM element, the pseudolayer or the uiLayer by id. 
        this.id = pseudolayer.id;
        // the name of the pseudolayer on the ui;
        this.name = `Test layer ${layerNumber}`;
        // the pseudolayer that is rendered -> updated every time a parameter is updated. reset to originalPseudolayer on reset.
        this.pseudolayer = pseudolayer;
        // the original layer -> should never change
        this.originalPseudolayer = pseudolayer;
        // tracks which guis have been used, and the pseduolayer generated by that gui
        this._processingTracker = {};
        // html required to add the layer to the layer panel of the ui
        const html = `<div class="layer" id="${this.id}" data-id="${this.id}">
                        <button class="delete_layer" data-id="${this.id}">&#10060</button>
                        <span id="Test layer ${layerNumber}" class="layer_text" data-id="${this.id}">${this.name}</span>
                     </div>`
        this.html = document.createElement("div");
        this.html.innerHTML = html;
    }

    getPseudolayer = () => {
        return this.pseudolayer;
    }
}

export class Ui {
    constructor(webgl, constructor) {
        // the WebGLCanvas object
        this._webgl = webgl;
        // constructors for the shader programs
        this._constructor = constructor;
        // object where keys are the id of the uiLayer, and the property is the uiLayer
        this._uiLayers = {};
        // ordered array -> first element in this array is the pseudolayer that is rendered
        this._uiLayersOrder = [];
        // which layer is currently selected on the ui, and therefore is the target of any processing
        this.activeUiLayer = false;
        // which, if any, gui is currently rendered on the screen
        this.activeGui = false;
        // the previous gui that was rendered -> prevents the updated base pseudolayer from being used
        // if the same gui is used consecutively
        this._lastGui = false;
        // an object containing the methods that need to be called when a gui is to be opened
        this.guis = {
            // processing guis
            "rgbaManipulation": this.rgbaManipulationGui,
            "rgbFiltering": this.rgbFilteringGui,
            "rgbPercentageFiltering": this.rgbPercentageFilteringGui,
            "apply3x3Kernel": this.apply3x3KernelGui,
            "sobelEdgeDetection": this.sobelEdgeDetection,
            "greyscale": this.greyscale,
            "stackLayers": this.stackLayers,
            // visualisation guis
            "compareLayers": this.compareLayers,
        }
    }

    // add a pseudolayer to the ui, generating a new uiLayer. this uiLayer is added to the end 
    // of the existing uiLayers
    addUiLayer = (pseudolayer) => {
        // the number of the uiLayer -> for naming
        const layerNumber = this._uiLayersOrder.length + 1;
        // creates a new uiLayer
        const uiLayer = new UiLayer(pseudolayer, layerNumber);
        // adds the uiLayer to the layer tracker, where the uiLayer can directly be called via the id of the layer
        this._uiLayers[uiLayer.id] = uiLayer;
        // update the uiLayersOrder -> adds to the end by default, therefore this layer is rendered last
        this._uiLayersOrder.push(uiLayer.id);
        // adds the html from the uiLayer to update the map
        document.getElementById("layers_holder").appendChild(uiLayer.html);
        // determines which of the current uiLayers should be rendered
        this._renderActiveUiLayer();
    }

    // removes a uiLayer 
    removeUiLayer = (uiLayer) => {
        // gets the id of the uiLayer to be removed
        const uiLayerDeleteId = uiLayer.dataset.id;
        // removes the uiLayer from the uiLayers object
        delete this._uiLayers[uiLayerDeleteId];
        // removes the uiLayer from uiLayersOrder array
        this._uiLayersOrder = this._uiLayersOrder.filter(item => item !== parseInt(uiLayerDeleteId));
        // updates the active uiLayer with the first element in the uiLayersOrder array if a uiLayer exists
        if (this._uiLayersOrder.length > 0) {
            const newActiveUiLayerId = this._uiLayersOrder[0];
            const newActiveUiLayer = this._uiLayers[newActiveUiLayerId];
            // sets the active layer
            this.activeUiLayer = newActiveUiLayer;
            // update the css
            document.getElementById(newActiveUiLayerId).classList.add("selected");
        } else {
            this.activeUiLayer = false;
            this._webgl.clearCanvas();
        }
        // deletes the uiLayer from the DOM
        document.getElementById(uiLayerDeleteId).remove();
        // determines which of the current uiLayers should be rendered
        this._renderActiveUiLayer();
    }

    // updates a uiLayer, by changing the "pseudolayer" property of the uiLayer to the new 
    // pseudolayer to be rendered
    updateUiLayer = (uiLayer, pseudolayer) => {
        uiLayer.pseudolayer = pseudolayer;
        // determines which of the current uiLayers should be rendered
        this._renderActiveUiLayer();
    }

    // resets a layer by changing the pseudolayer property back to the originalPseudolayer property.
    // also resets the state object of that layer, removing any gui values.
    // then re-renders the gui with the reset values, and re-renders the pseudolayer
    resetUiLayer = () => {
        // gets the DOM element id of the currently active gui
        const activeGuiId = this.activeGui.id;
        // gets the method required to build that gui
        const buildGui = this.guis[activeGuiId];
        // sets the pseudolayer of the uiLayer to the original pseudolayer
        this.activeUiLayer.pseudolayer = this.activeUiLayer.originalPseudolayer;
        // remove all pseudolayers from the processing tracker
        this.activeUiLayer._processingTracker = {};
        // removes the current gui
        this.removeGui();
        // rebuilds the current gui, with reset values
        buildGui();
        // determines which of the current layers should be rendered
        this._renderActiveUiLayer();
    }

    // activates a layer when clicked
    activateUiLayer = (uiLayerToActivate) => {
        // remove selected class from any element that is currently selected
        const selectedElements = document.getElementsByClassName("selected");
        for (let x = 0; x < selectedElements.length; x++) {
            selectedElements[x].classList.remove("selected");
        }
        // set the layer as the active uiLayer
        this.activeUiLayer = uiLayerToActivate;
        // applies the selected class for css
        const uiLayerId = uiLayerToActivate.id;
        const uiLayerDiv = document.getElementById(uiLayerId);
        uiLayerDiv.classList.add("selected");
        // updates the uiLayer array, to move the active uiLayer to the front of the array
        this._uiLayersOrder = this._uiLayersOrder.filter(item => item !== parseInt(uiLayerId));
        this._uiLayersOrder.unshift(parseInt(uiLayerId));
        // determines which of the current layers should be rendered (which should be this one)
        this._renderActiveUiLayer();
    }

    // determines which layer should be rendered by webGL, based on which layer is selected
    _renderActiveUiLayer = () => {
        // if there is currently a uiLayer
        if (this.activeUiLayer) {
            // render the pseudolayer of the active uiLayer
            const pseudoLayerToRender = this.activeUiLayer.pseudolayer;
            this._webgl.activatePseudolayer(pseudoLayerToRender);
        } else if (this._uiLayersOrder.length > 0) {
            // if it's the first layer to be added, render and set as active
            const uiLayerIdToActivate = this._uiLayersOrder[0];
            const uiLayerToActivate = this._uiLayers[uiLayerIdToActivate];
            const pseudoLayerToRender = uiLayerToActivate.pseudolayer;
            document.getElementById(uiLayerIdToActivate).classList.add("selected");
            this.activeUiLayer = uiLayerToActivate;
            this._webgl.activatePseudolayer(pseudoLayerToRender);
        } else {
            // otherwise stop rendering
            this._webgl.activatePseudolayer();
        }
    }

    // argument is a dom element that corresponds to a ui layer - activates the corresponding ui layer
    // using activateUiLayer method
    activateUiLayerFromDOM = (targetLayer) => {
        // get id of the layer that was clicked
        const uiLayerId = targetLayer.dataset.id;
        const uiLayer = this._uiLayers[uiLayerId];
        this.activateUiLayer(uiLayer);
    }

    // get a ui layer from a pseudolayer
    getUiLayerFromPseudolayer = (pseudolayer) => {
        return this._uiLayers[pseudolayer.id];
    }

    // adds a gui to the correct position in the DOM -> accepts the html string of the gui
    _addGuiToDOM = (string) => {
        // creates an html element, appends the html then gets rid of the parent div
        var htmlElement = document.createElement("div");
        htmlElement.innerHTML = string;
        htmlElement = htmlElement.firstChild;
        // appends the div to the  correct place in the DOM
        const processingGui = document.getElementById("gui");
        processingGui.style.visibility = "visible";
        const insertPoint = document.getElementById("gui_actions");
        insertPoint.insertAdjacentElement('beforebegin', htmlElement);
        return htmlElement;
    }

    // removes the gui from the DOM
    removeGui = () => {
        // remove the gui placeholder
        const processingGui = document.getElementById("gui");
        processingGui.style.visibility = "hidden";
        // remove the gui
        processingGui.removeChild(this.activeGui);
        // event listeners *should* be garbage collected
        // hide any elements necessary -> for extras associated with the gui
        let toHide = document.getElementsByClassName("gui_close_hide");
        for (let x = 0; x < toHide.length; x++) {
            toHide[x].style.visibility = "hidden";;
        }
        // remove any elements necessary -> for extras associated with the gui
        let toRemove = document.getElementsByClassName("gui_close_remove");
        for (let x = 0; x < toRemove.length; x++) {
            toRemove[x].remove();
        }
    }

    // processing guis
    rgbaManipulationGui = () => {
        // check if a pseudolayer has been created for this gui yet
        if (!("rgbaManipulationGui" in this.activeUiLayer._processingTracker)) {
            // set default values of the pseudolayer
            var rgbam_multiplier = [1.0, 1.0, 1.0, 1.0];
        } else {
            // get the named input for the pseuodlayer associated with this gui
            var rgbam_multiplier = this.activeUiLayer._processingTracker.rgbaManipulationGui.variables.rgbam_multiplier;
        }

        // generate gui -> can be unstyled, as will resize to fit generic gui container, or can be styled in guis.css
        const html = `<div id="rgbaManipulation" class="inner_gui">
                          <p class="gui_title">Multiply RGBA</p>
                          <p class="gui_text">Red: <span id="red_value">${rgbam_multiplier[0]}</span></p>
                          <input type="range" min="0" max="300" value="${rgbam_multiplier[0]*100}" class="gui_slider" id="red_slider">
                          <p class="gui_text">Green: <span id="green_value">${rgbam_multiplier[1]}</span></p>
                          <input type="range" min="0" max="300" value="${rgbam_multiplier[1]*100}" class="gui_slider" id="green_slider">
                          <p class="gui_text">Blue: <span id="blue_value">${rgbam_multiplier[2]}</span></p>
                          <input type="range" min="0" max="300" value="${rgbam_multiplier[2]*100}" class="gui_slider" id="blue_slider">
                      </div>`
        const gui = this._addGuiToDOM(html);
        this.activeGui = gui;

        // add event handlers -> these should be garbage collected when the gui is removed
        function addSliderEvent(sliderId, valueId, ui) {
            document.getElementById(sliderId).oninput = () => {
                // get the input values from the sliders
                let red = document.getElementById("red_slider").value/100;
                let green = document.getElementById("green_slider").value/100;
                let blue = document.getElementById("blue_slider").value/100;
                document.getElementById(valueId).innerHTML = document.getElementById(sliderId).value/100;
                // create a pseudolayer for this gui if one doesn't exist. we do it inside the event handler because we only want to generate the pseudolayer
                // if the gui value is actually changed. also helps for when we have inputs that are determined by the gui
                if (!("rgbaManipulationGui" in ui.activeUiLayer._processingTracker)) {
                    let pseudolayer = ui._constructor.rgbaManipulation({
                        webgl: ui._webgl, 
                        rgbam_image: ui.activeUiLayer.pseudolayer,
                        rgbam_multiplier: [red, green, blue, 1.0],
                    });
                    ui.activeUiLayer._processingTracker["rgbaManipulationGui"] = pseudolayer;
                    ui.updateUiLayer(ui.activeUiLayer, pseudolayer);
                // if the pseudolayer for the gui has been created (which it will have been every time except the first time this event fires)
                // we just update the pseudolayer, rather than creating a new one
                } else {
                    // we update the pseudolayer value, using object mutation to our advantage
                    let targetPseudolayer = ui.activeUiLayer._processingTracker.rgbaManipulationGui;
                    targetPseudolayer.updateVariable("rgbam_multiplier", [red, green, blue, 1.0]);
                    // we're just updating the active ui layer, so we dont need to generate a new layer
                    ui._renderActiveUiLayer();
                }
            }
        }

        addSliderEvent("red_slider", "red_value", this);
        addSliderEvent("green_slider", "green_value", this);
        addSliderEvent("blue_slider", "blue_value", this);
    }

    rgbFilteringGui = () => {
        if (!("rgbFilteringGui" in this.activeUiLayer._processingTracker)) {
            var rgbf_filter = [1.0, 1.0, 1.0];
            var rgbf_removed = [0.0, 0.0, 0.0, 1.0];
            var rgbfd1_remove = ">";
        } else {
            var rgbf_filter = this.activeUiLayer._processingTracker.rgbFilteringGui.variables.rgbf_filter;
            var rgbf_removed = this.activeUiLayer._processingTracker.rgbFilteringGui.variables.rgbf_removed;
            var rgbfd1_remove = this.activeUiLayer._processingTracker.rgbFilteringGui.variables.rgbfd1_remove;
        }

        const html = `<div id="rgbFiltering" class="inner_gui">
                          <p class="gui_title">Filter RGB</p>
                          <p class="gui_text">Value to filter:</p>
                          <p class="gui_text">Red: <span id="red_value">${rgbf_filter[0]*255}</span></p>
                          <input type="range" min="0" max="255" value="${rgbf_filter[0]*255}" class="gui_slider" id="red_slider">
                          <p class="gui_text">Green: <span id="green_value">${rgbf_filter[1]*255}</span></p>
                          <input type="range" min="0" max="255" value="${rgbf_filter[1]*255}" class="gui_slider" id="green_slider">
                          <p class="gui_text">Blue: <span id="blue_value">${rgbf_filter[2]*255}</span></p>
                          <input type="range" min="0" max="255" value="${rgbf_filter[2]*255}" class="gui_slider" id="blue_slider">
                          <p class="gui_text">Operator:</p>
                          <select name="operator" id="operator">
                            <option value="&gt" selected>&gt</option>
                            <option value="&lt">&lt</option>
                          </select><br><br>
                      </div>`
        const gui = this._addGuiToDOM(html);
        this.activeGui = gui;

        function addSliderEvent(sliderId, valueId, ui) {
            document.getElementById(sliderId).oninput = () => {
                let red = document.getElementById("red_slider").value/255;
                let green = document.getElementById("green_slider").value/255;
                let blue = document.getElementById("blue_slider").value/255;
                let operator = document.getElementById("operator").value;
                document.getElementById(valueId).innerHTML = document.getElementById(sliderId).value;
                if (!("rgbFilteringGui" in ui.activeUiLayer._processingTracker)) {
                    let pseudolayer = ui._constructor.rgbFiltering({
                        webgl: ui._webgl, 
                        rgbf_image: ui.activeUiLayer.pseudolayer, 
                        rgbf_filter: [red, green, blue], 
                        rgbf_removed: rgbf_removed, 
                        rgbfd1_remove: operator,
                    });
                    ui.activeUiLayer._processingTracker["rgbFilteringGui"] = pseudolayer;
                    ui.updateUiLayer(ui.activeUiLayer, pseudolayer);
                } else {
                    let targetPseudolayer = ui.activeUiLayer._processingTracker.rgbFilteringGui;
                    targetPseudolayer.updateVariable("rgbf_filter", [red, green, blue]);
                    ui._renderActiveUiLayer();
                }
            }
        }

        addSliderEvent("red_slider", "red_value", this);
        addSliderEvent("green_slider", "green_value", this);
        addSliderEvent("blue_slider", "blue_value", this);

        document.getElementById("operator").onchange = () => {
            let red = document.getElementById("red_slider").value/255;
            let green = document.getElementById("green_slider").value/255;
            let blue = document.getElementById("blue_slider").value/255;
            let operator = document.getElementById("operator").value;
            if (!("rgbFilteringGui" in this.activeUiLayer._processingTracker)) {
                let pseudolayer = this._constructor.rgbFiltering({
                    webgl: this._webgl, 
                    rgbf_image: this.activeUiLayer.pseudolayer, 
                    rgbf_filter: [red, green, blue], 
                    rgbf_removed: rgbf_removed, 
                    rgbfd1_remove: operator,
                });
                this.activeUiLayer._processingTracker["rgbFilteringGui"] = pseudolayer;
                this.updateUiLayer(this.activeUiLayer, pseudolayer);
            } else {
                this._webgl.updateDynamics({"rgbfd1_remove": operator}, this.activeUiLayer._processingTracker.rgbFilteringGui);
                this._renderActiveUiLayer();
            }
        }
    }

    rgbPercentageFilteringGui = () => {
        if (!("rgbPercentageFiltering" in this.activeUiLayer._processingTracker)) {
            var rgbfp_filter = [1.0, 1.0, 1.0];
            var rgbfp_removed = [0.0, 0.0, 0.0, 1.0];
            var rgbfpd1_remove = ">";
        } else {
            var rgbfp_filter = this.activeUiLayer._processingTracker.rgbPercentageFiltering.variables.rgbfp_filter;
            var rgbfp_removed = this.activeUiLayer._processingTracker.rgbPercentageFiltering.variables.rgbfp_removed;
            var rgbfpd1_remove = this.activeUiLayer._processingTracker.rgbPercentageFiltering.variables.rgbfpd1_remove;
        }

        const html = `<div id="rgbPercentageFiltering" class="inner_gui">
                          <p class="gui_title">Filter RGB by %</p>
                          <p class="gui_text">Value to filter:</p>
                          <p class="gui_text">Red: <span id="red_value">${rgbfp_filter[0]*100}%</span></p>
                          <input type="range" min="0" max="100" value="${rgbfp_filter[0]*100}" class="gui_slider" id="red_slider">
                          <p class="gui_text">Green: <span id="green_value">${rgbfp_filter[1]*100}%</span></p>
                          <input type="range" min="0" max="100" value="${rgbfp_filter[1]*100}" class="gui_slider" id="green_slider">
                          <p class="gui_text">Blue: <span id="blue_value">${rgbfp_filter[2]*100}%</span></p>
                          <input type="range" min="0" max="100" value="${rgbfp_filter[2]*100}" class="gui_slider" id="blue_slider">
                          <p class="gui_text">Operator:</p>
                          <select name="operator" id="operator">
                            <option value="&gt" selected>&gt</option>
                            <option value="&lt">&lt</option>
                          </select><br><br>
                      </div>`
        const gui = this._addGuiToDOM(html);
        this.activeGui = gui;

        function addSliderEvent(sliderId, valueId, ui) {
            document.getElementById(sliderId).oninput = () => {
                let red = document.getElementById("red_slider").value/100;
                let green = document.getElementById("green_slider").value/100;
                let blue = document.getElementById("blue_slider").value/100;
                let operator = document.getElementById("operator").value;
                document.getElementById(valueId).innerHTML = document.getElementById(sliderId).value + "%";
                if (!("rgbPercentageFiltering" in ui.activeUiLayer._processingTracker)) {
                    let pseudolayer = ui._constructor.rgbPercentageFiltering({
                        webgl: ui._webgl, 
                        rgbfp_image: ui.activeUiLayer.pseudolayer, 
                        rgbfp_filter: [red, green, blue], 
                        rgbfp_removed: rgbfp_removed, 
                        rgbfpd1_remove: operator
                    });
                    ui.activeUiLayer._processingTracker["rgbPercentageFiltering"] = pseudolayer;
                    ui.updateUiLayer(ui.activeUiLayer, pseudolayer);
                } else {
                    let targetPseudolayer = ui.activeUiLayer._processingTracker.rgbPercentageFiltering;
                    targetPseudolayer.updateVariable("rgbfp_filter", [red, green, blue]);
                    ui._renderActiveUiLayer();
                }
            }
        }

        addSliderEvent("red_slider", "red_value", this);
        addSliderEvent("green_slider", "green_value", this);
        addSliderEvent("blue_slider", "blue_value", this);

        document.getElementById("operator").onchange = () => {
            let red = document.getElementById("red_slider").value/100;
            let green = document.getElementById("green_slider").value/100;
            let blue = document.getElementById("blue_slider").value/100;
            let operator = document.getElementById("operator").value;
            if (!("rgbPercentageFiltering" in this.activeUiLayer._processingTracker)) {
                let pseudolayer = this._constructor.rgbPercentageFiltering({
                    webgl: this._webgl, 
                    rgbfp_image: this.activeUiLayer.pseudolayer, 
                    rgbfp_filter: [red, green, blue], 
                    rgbfp_removed: rgbfp_removed, 
                    rgbfpd1_remove: operator
                });
                this.activeUiLayer._processingTracker["rgbPercentageFiltering"] = pseudolayer;
                this.updateUiLayer(this.activeUiLayer, pseudolayer);
            } else {
                this._webgl.updateDynamics({"rgbfpd1_remove": operator}, this.activeUiLayer._processingTracker.rgbPercentageFiltering);
                this._renderActiveUiLayer();
            }
        }
    }

    apply3x3KernelGui = () => {
        if (!("apply3x3Kernel" in this.activeUiLayer._processingTracker)) {
            var a3k_kernel = [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0];
            var a3k_kernelWeight = 1.0;
        } else {
            var a3k_kernel = this.activeUiLayer._processingTracker.apply3x3Kernel.variables.a3k_kernel;
            var a3k_kernelWeight = this.activeUiLayer._processingTracker.apply3x3Kernel.variables.a3k_kernelWeight;
        }

        const html = `<div id="apply3x3Kernel" class="inner_gui">
                        <p class="gui_title">Apply 3x3 kernel</p>
                        <table id="kernel_table">
                            <tr>
                                <td><div class="kernel_input" data-index="0" contenteditable>${a3k_kernel[0]}</div></td>
                                <td><div class="kernel_input" data-index="1" contenteditable>${a3k_kernel[1]}</div></td>
                                <td><div class="kernel_input" data-index="2" contenteditable>${a3k_kernel[2]}</div></td>
                            </tr>
                            <tr>
                                <td><div class="kernel_input" data-index="3" contenteditable>${a3k_kernel[3]}</div></td>
                                <td><div class="kernel_input" data-index="4" contenteditable>${a3k_kernel[4]}</div></td>
                                <td><div class="kernel_input" data-index="5" contenteditable>${a3k_kernel[5]}</div></td>
                            </tr>
                            <tr>
                                <td><div class="kernel_input" data-index="6" contenteditable>${a3k_kernel[6]}</div></td>
                                <td><div class="kernel_input" data-index="7" contenteditable>${a3k_kernel[7]}</div></td>
                                <td><div class="kernel_input" data-index="8" contenteditable>${a3k_kernel[8]}</div></td>
                            </tr>
                        </table>
                        <p class="gui_text">Multiplier</p>
                        <input id="kernel_multiplier" type="number" min="1" max="16" value="${a3k_kernelWeight}">
                        <br><br>
                        <input id="apply_kernel" type="button" value="Apply">
                        <br><br>
                    </div>`
        const gui = this._addGuiToDOM(html);
        this.activeGui = gui;

        document.getElementById("apply_kernel").onclick = () => {
            let kernelInputs = document.getElementsByClassName("kernel_input");
            let updatedKernel = Array(9);
            for (let x = 0; x < kernelInputs.length; x++) {
                let kernelInput = kernelInputs[x];
                let kernelInputIndex = parseInt(kernelInput.dataset.index);
                updatedKernel[kernelInputIndex] = parseInt(kernelInput.innerHTML);
            }
            let updateKernelWeight = parseInt(document.getElementById("kernel_multiplier").value);
            if (!("apply3x3Kernel" in this.activeUiLayer._processingTracker)) {
                let pseudolayer = this._constructor.apply3x3Kernel({
                    webgl: this._webgl, 
                    a3k_image: this.activeUiLayer.pseudolayer,
                    a3k_kernel: updatedKernel, 
                    a3k_kernelWeight: updateKernelWeight
                });
                this.activeUiLayer._processingTracker["apply3x3Kernel"] = pseudolayer;
                this.updateUiLayer(this.activeUiLayer, pseudolayer);
            } else {
                let targetPseudolayer = this.activeUiLayer._processingTracker.apply3x3Kernel;
                targetPseudolayer.updateVariable("a3k_kernel", updatedKernel);
                targetPseudolayer.updateVariable("a3k_kernelWeight", updateKernelWeight);
                this._renderActiveUiLayer();
            }
        }
    }

    sobelEdgeDetection = () => {
        if (!("sobelEdgeDetection" in this.activeUiLayer._processingTracker)) {
            let pseudolayer = this._constructor.sobelEdgeDetection({
                webgl: this._webgl, 
                sed_image: this.activeUiLayer.pseudolayer,
            });
            this.activeUiLayer._processingTracker["sobelEdgeDetection"] = pseudolayer;
            this.updateUiLayer(this.activeUiLayer, pseudolayer);
        }
    }

    greyscale = () => {
        if (!("greyscale" in this.activeUiLayer._processingTracker)) {
            let pseudolayer = this._constructor.greyscale({
                webgl: this._webgl, 
                gs_image: this.activeUiLayer.pseudolayer,
            });
            this.activeUiLayer._processingTracker["greyscale"] = pseudolayer;
            this.updateUiLayer(this.activeUiLayer, pseudolayer);
        }
    }

    stackLayers = () => {
        if (!("stackLayers" in this.activeUiLayer._processingTracker)) {
            var sl1_weight = 1.0;
            var sl2_weight = 1.0;
            var sl_divisor = 2.0;
        } else {
            var sl1_weight = this.activeUiLayer._processingTracker.stackLayers.variables.sl1_weight;
            var sl2_weight = this.activeUiLayer._processingTracker.stackLayers.variables.sl2_weight;
            var sl_divisor = this.activeUiLayer._processingTracker.stackLayers.variables.sl_divisor;
        }

        // get all of the available layers for the second layer dropdown
        var layerOptions = "";
        for (let key of Object.keys(this._uiLayers)) {
            let uiLayer = this._uiLayers[key];
            layerOptions += `<option id=${uiLayer.id}>${uiLayer.name}</option>`
        }

        const html = `<div id="stackLayers" class="inner_gui">
                          <p class="gui_title">Stack layers</p>
                          <p class="gui_text">This layer weight:</p>
                          <input id="layer1_weight" type="number" min="1" max="5" value="${sl1_weight}">
                          <p class="gui_text">Layer 2 input:</p>
                          <select id="sl_layer2_dropdown">
                              ${layerOptions}
                          </select>
                          <p class="gui_text">Layer 2 weight:</p>
                          <input id="layer2_weight" type="number" min="1" max="5" value="${sl2_weight}">
                          <p class="gui_text">Divisor:</p>
                          <input id="stack_layers_divisor" type="number" min="1" max="5" value="${sl_divisor}">
                          <br><br>
                          <input id="apply_stack_layers" type="button" value="Apply">
                          <br><br>
                      </div>`
        const gui = this._addGuiToDOM(html);
        this.activeGui = gui;

        document.getElementById("apply_stack_layers").onclick = () => {
            // first we need to reconstruct the selected ui layer
            let selectElement = document.getElementById("sl_layer2_dropdown");
            let selectedElementId = selectElement[selectElement.selectedIndex].id;
            let targetPseudolayer2 = this._uiLayers[selectedElementId].pseudolayer;
            // then get input values
            let layer1_weight = parseInt(document.getElementById("layer1_weight").value);
            let layer2_weight = parseInt(document.getElementById("layer2_weight").value);
            let overall_divisor = parseInt(document.getElementById("stack_layers_divisor").value);
            if (!("stackLayers" in this.activeUiLayer._processingTracker)) {
                let pseudolayer = this._constructor.stackLayers({
                    webgl: this._webgl,
                    sl1_image: this.activeUiLayer.pseudolayer,
                    sl2_image: targetPseudolayer2,
                    sl1_weight: layer1_weight,
                    sl2_weight: layer2_weight,
                    sl_divisor: overall_divisor,
                    sl_ignore: [0.0, 0.0, 0.0, 1.0],
                    sld1_operator: '==',
                })
                this.activeUiLayer._processingTracker["stackLayers"] = pseudolayer;
                this.updateUiLayer(this.activeUiLayer, pseudolayer);
            } else {
                let targetPseudolayer = this.activeUiLayer._processingTracker.stackLayers;
                targetPseudolayer.updateVariable("sl1_weight", layer1_weight);
                targetPseudolayer.updateVariable("sl2_weight", layer2_weight);
                targetPseudolayer.updateVariable("sl_divisor", overall_divisor);
                targetPseudolayer.updateInput("sl2_image", targetPseudolayer2);
                this._renderActiveUiLayer();
            }
        }
    }

    // visualisation guis
    compareLayers = () => {
        var layerOptions = "";
        for (let key of Object.keys(this._uiLayers)) {
            let uiLayer = this._uiLayers[key];
            if (uiLayer.id !== this.activeUiLayer.id) {
                layerOptions += `<option id=${uiLayer.id}>${uiLayer.name}</option>`;
            }
        }

        // generate gui -> can be unstyled, as will resize to fit generic gui container, or can be styled in guis.css
        const html = `<div id="compareLayers" class="inner_gui">
                          <p class="gui_title">Compare layers</p>
                          <p class="gui_text">Comparison layer:</p>
                          <select id="cl_layer2_dropdown">
                              ${layerOptions}
                          </select>
                          <br><br>
                      </div>`
        const gui = this._addGuiToDOM(html);
        this.activeGui = gui;

        // set the swipe container as visible at the bottom of the screen
        let swipeContainer = document.getElementById("comparison_swipe_container");
        swipeContainer.style.visibility = "visible";
        // event handler
        document.getElementById("comparison_swipe").oninput = () => {
            let widthValue = document.getElementById("comparison_swipe").value/ 100;
            let selectElement = document.getElementById("cl_layer2_dropdown");
            let selectedElementId = selectElement[selectElement.selectedIndex].id;
            let targetPseudolayer2 = this._uiLayers[selectedElementId].pseudolayer;
            if (!("compareLayers" in this.activeUiLayer._processingTracker)) {
                let pseudolayer = this._constructor.compareLayers({
                    webgl: this._webgl, 
                    cl_image1: this.activeUiLayer.pseudolayer,
                    cl_image2: targetPseudolayer2,
                    cl_width: widthValue,
                });
                this.activeUiLayer._processingTracker["compareLayers"] = pseudolayer;
                this.updateUiLayer(this.activeUiLayer, pseudolayer);
            } else {
                let targetPseudolayer = this.activeUiLayer._processingTracker.compareLayers;
                targetPseudolayer.updateInput("cl_image2", targetPseudolayer2);
                targetPseudolayer.updateVariable("cl_width", widthValue);
                this._renderActiveUiLayer();
            }
        }

        // hide gui when slider starts
        document.getElementById("comparison_swipe").onmousedown = () => {
            document.getElementById("gui_container").style.opacity = 0;
        }

        // show gui when slider ends
        document.getElementById("comparison_swipe").onmouseup = () => {
            document.getElementById("gui_container").style.opacity = 1;
        }

        // hide gui when user moves
        this.activeUiLayer.pseudolayer.getFirstMap().on("movestart", () => {
            console.log("moving")
            document.getElementById("gui_container").style.opacity = 0;
        })

        // show gui when user stops moving
        this.activeUiLayer.pseudolayer.getFirstMap().on("moveend", () => {
            document.getElementById("gui_container").style.opacity = 1;
        })

        
        // close processing gui -> hide gui container and remove gui. additional
        document.addEventListener('click', (e) => {
            const closeButton = e.target;
            if (closeButton && closeButton.id === "close_gui"){
                // revert the layer on close
                this.updateUiLayer(this.activeUiLayer, this.activeUiLayer.originalPseudolayer);
                // remove state information
                delete this.activeUiLayer._processingTracker.compareLayers;
            }
        });
    }
}